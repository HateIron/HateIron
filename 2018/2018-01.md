# 2018-01月

## [上月](../2017/2017-12.html)                                                        [下月](./2018-02.html)   <span id="jump"></span>

[TOC]

##2018-01-06

### 一、[mockcpp-2.6.tar.gz](./2018-01/mockcpp-2.6.tar.gz) 的安装,以及问题解决

```shell
在没有启用 c++11新特性的编译器上，很顺利
tar -xf mockcpp-2.6.tar.gz
cmake .
make 
make install

在gcc-6.2.0上编译，则出现错误：
./mockcpp/incude/mockcpp/mockcpp.h:59:8 错误: expected unqualified-id before 'static_assert'

然后打开这个 mockcpp.h
将原来的 static_assert 定义注释掉，换一种写法：
#define EIGEN_STATIC_ASSERT(CONDITION,MSG)\
    {Eigen::internal::static_assertion<bool(CONDITION)>::MSG;}
    
#if 0
template <bool condition>
struct static_assert
{
  typedef int static_assert_failure[condition ? 1 : -1];
};
#endif
```



### 二、[shttpd](./2018-01/shttpd.tar) 研究

####1、拿来主义，选择自己的端口号

```shell
在 config.h 中，修改自己的端口：
#define	LISTENING_PORTS	"8888"		/* Default listening ports	*/
```



#### 2、研究 example.c 里面的内容

```
    /* Register an index page under two URIs */
    shttpd_register_uri(ctx, "/", &show_index, (void *) &data);
    shttpd_register_uri(ctx, "/abc.html", &show_index, (void *) &data);
```

> 这两行表示注册自己的处理函数，即输入`http://192.168.1.34:8888/abc.html` 或者`http://192.168.1.34:8888` 都会执行 show_index 函数
>
>   ```c
> int    data          = 1234567;
> shttpd_register_uri(ctx, "/", &show_index, (void *) &data);
>   ```
>
> 表示 `static void show_index(struct shttpd_arg *arg)` 的入参 `shttpd_arg ` 的数据区 `user_data` 传的是一个整数。这里应该仅仅是一个说明作用，方便以后数据转化
>
> ```
> struct shttpd_arg
> {
>     void		*priv;		/* Private! Do not touch!	*/
>     void		*state;		/* User state		    	*/
>     void		*user_data;	/* Data from register_uri()	*/
>     struct ubuf	in;		    /* Input is here, POST data	*/
>     struct ubuf	out;		/* Output goes here		    */
>
>     unsigned int	flags;
>     
> #define	SHTTPD_END_OF_OUTPUT	1	/* No more data do send	    	*/
> #define	SHTTPD_CONNECTION_ERROR	2	/* Server closed the connection	*/
> #define	SHTTPD_MORE_POST_DATA	4	/* arg->in has incomplete data	*/
> #define	SHTTPD_POST_BUFFER_FULL	8	/* arg->in has max data		    */
> #define	SHTTPD_SSI_EVAL_TRUE	16	/* SSI eval callback must set it*/
> #define	SHTTPD_SUSPEND		    32  /* User wants to suspend output	*/
> };
> ```
>
> `show_index`中，接收用户数据的方法
>
> ![shttpd_modify_int.png](./2018-01/shttpd_modify_int.png)
>
> 
>
> 同样道理，如果要处理的内容为字符串，则更加简单，只需要注册一个足够大的 buffer，然后就可以随便搞了
>
> 如前面传过来的字符串为 `function para1`,则用法为`sscanf(value,"funcion %d", &my_para)`,成功将 para1 转化为 int 型，并保存在 my_data 里面
>
> 

#### 4、基于这个方法实现登录界面的想法

> ##### 1、首先用户界面是一个登录框，登录框界面为 C 代码实现
>
> ##### 2、用户输入密码后，如果不正确，多追回一个错误提示，继续输入
>
> #####3、用户如果输入正确，可以给出一个自动跳转链接，3秒后自动登录，可在这段时间打印一个`正在登录`
>
> #####5、多个终端，可以通过它的IP来判断登录
>
> ##### 6、涉及到加密问题
>
> #####5、可用命令行访问： curl http://192.168.1.34:8888/page1.html?name1=9907





##2018-01-13

###一、继续 shttpd 的研究

将诸小模块都放到 github 上面，日后方便使用，需要时随便拿一个就用

```https://user:passwd@github.com/HateIron/IndependentModules.git```



### 二、git commit 默认模板设置

#### 1、git commit 时，处于 vim 编辑界面时， `ctrl + z`可以让 vim 中断退出，从而放弃本次提交。普通的 vim 编辑时，也可以用 `ctrl + z` 快速退出

#### 2、设置 `git commit`默认模板

> 1）、在根目录建立模板文件 xxx_template ，内容如下:
>
> ```
> [入库原因]：增加A功能
> [入库影响]：影响B、C功能
> [入库描述]：无
> [入 库 人]：某某某
> ```
>
> 2）、设置模板
>
> > A、只能设置当前分支提交模板的命令：
>
> ```shell
> git config commit.template [模板文件名]
> ```
>
> 配置之后，查看  `.git/config`,发现最后一行，就是刚刚配置的模板名称：
>
> ```shell
> [core]
>         repositoryformatversion = 0
>         filemode = false
>         bare = false
>         logallrefupdates = true
>         symlinks = false
>         ignorecase = true
> [user]
>         mail = "15900748704@139.com"
>         name = "HateIron"
> [remote "origin"]
>         url = https://user:passwd@github.com/HateIron/HateIron.git
>         fetch = +refs/heads/*:refs/remotes/origin/*
> [branch "master"]
>         remote = origin
>         merge = refs/heads/master
> [commit]
>         template = ./HateIron_Template.txt
> ```
>
> 
>
> > B、设置全局提交模板的命令
>
> ```shell
> git config --global commit.template [模板文件名]
> ```
>
> 3）、设置文本编辑器，命令如下：
>
> ```shell
> git config --global core.editor [编辑器的名字]
> 如：
> git config --global core.editor vi
> ```
>
> 4）、提交代码
>
> ```
> git add ./
> git commit
> ```
>
> 5）、最后将代码提交到远程分支
>
> ```
> git push
> ```
>
> 



## 2018-01-14

###[16:05]发现一个人家写好的工程[dos2unix](./2018/dos2unix-6.0.1.tar.gz)

> ####1、它支持多种操作系统，支持`dos2unix`/`unix2dos`，在 CentOS7上成功编译安装。
>
> 
>
> ####2、然后在 debian 8 上编译，问题不断
>
> #####A、编译失败
>
> ```shell
> root@debian:/home/debian/study/dos2unix-6.0.1# make
> msgfmt -c po/de.po -o po/de.mo
> make: msgfmt: Command not found
> Makefile:326: recipe for target 'po/de.mo' failed
> make: *** [po/de.mo] Error 127
> ```
>
> #####B、解决[gettext-0.18.1.1.tar.gz](./2018/gettext-0.18.1.1.tar.gz)的问题，它的编译同样也不顺利
>
> 报错，说找不到 `msgfmt`,百度之，人家说是因为缺少`gettext-0.18.1.1.tar.gz`,于是下载一份，14M之多，
>
> configure成功，但是 make 失败:
>
> ```shell
> In file included from closeout.c:22:0:
> ./stdio.h:456:1: error: 'gets' undeclared here (not in a function)
>  _GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead");
>  ^
> Makefile:1106: recipe for target 'closeout.o' failed
> make[5]: *** [closeout.o] Error 1
> ```
>
> 然后找到 stdio.h，并将相应行注释掉
>
> ```shell
> root@debian:/home/debian/study/gettext-0.18.1.1# find ./ -name stdio.h
> ./gettext-runtime/gnulib-lib/stdio.h
> ./gettext-tools/libgettextpo/stdio.h
> ./gettext-tools/gnulib-lib/stdio.h
> ```
>
> 将报错的456行注释掉，并注释掉有同样问题的490行：
>
> ```c
> root@debian:/home/debian/study/gettext-0.18.1.1# vi ./gettext-tools/gnulib-lib/stdio.h +456
>  452 /* It is very rare that the developer ever has full control of stdin,                                  |||     _GL_STDIO_MACROEXPAND_A
>  453    so any use of gets warrants an unconditional warning.  Assume it is                                 |||     dprintf
>  454    always declared, since it is required by C89.  */                                                   |||     fclose
>  455 #undef gets                                                                                            |||     fflush
>  456 //_GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead");                                 |||     gets
>  457     
>   
>   .......
>   .......
>  488 _GL_CXXALIAS_RPL (fprintf, int, (FILE *fp, const char *format, ...));                                  |||     _GL_FTELL_WARN
>  489 # else                                                                                                 |||     ftell
>  490 //_GL_CXXALIAS_SYS (fprintf, int, (FILE *fp, const char *format, ...));                                |||     ftello
>  491 # endif   
> ```
>
> 编译一段时间，就会再次报同样的问题，因为生成了新的 stdio.h 文件
>
> 改完三个文件，终于编译完成，然后 `make install`顺利完成、
>
> ##### C、解决掉 `gettext`之后，继续前进，还是报错：
>
> ```shell
> root@debian:/home/debian/study/dos2unix-6.0.1# make
> msgfmt -c po/de.po -o po/de.mo
> msgfmt: error while loading shared libraries: libgettextsrc-0.18.1.so: cannot open shared object file: No such file or directory
> Makefile:326: recipe for target 'po/de.mo' failed
> make: *** [po/de.mo] Error 127
>
> 查找 .so 文件，是存在的
> root@debian:/home/debian/study/dos2unix-6.0.1# find / -name ibgettextsrc-0.18.1.so
> root@debian:/home/debian/study/dos2unix-6.0.1# find / -name libgettextsrc-0.18.1.so
> /home/debian/study/gettext-0.18.1.1/gettext-tools/src/.libs/libgettextsrc-0.18.1.so
> /usr/local/lib/libgettextsrc-0.18.1.so
> root@debian:/home/debian/study/dos2unix-6.0.1# 
> ```
>
> 百度之，说执行命令`ldconfig`就行，于是试了一下
>
> ```shell
> root@debian:/home/debian/study/dos2unix-6.0.1# ldconfig
> /sbin/ldconfig.real: /usr/local/lib/libstdc++.so.6.0.22-gdb.py is not an ELF file - it has the wrong magic bytes at the start.
>
> root@debian:/home/debian/study/dos2unix-6.0.1# 
> ```
>
> 然后再次 `make`就成功了，然后`make install`，圆满完成：
>
> ```shell
> root@debian:/home/debian/study/dos2unix-6.0.1# whereis dos2unix
> dos2unix: /usr/bin/dos2unix /usr/share/man/man1/dos2unix.1
> root@debian:/home/debian/study/dos2unix-6.0.1# 
> ```
>
> #### 3、在 Cygwin 上安装 `dos2unix`,很浪费时间
>
> ##### A、首先，它说找不到 `-liconv`
>
> 于是下载了一份[`iconv`](./2018/libiconv-1.14.tar.gz),然后编译之，很顺利
>
> `configure ; make ; make install`
>
> ##### B、然后回到 `dos2unix`，继续编译，还说找不到 `-liconv`
>
> ```shell
> $ make
> gcc dos2unix.o querycp.o common.o  -lintl -liconv -Wl,--enable-auto-import  -o dos2unix.exe
> /usr/lib/gcc/x86_64-pc-cygwin/5.4.0/../../../../x86_64-pc-cygwin/bin/ld: cannot find -liconv
> collect2: 错误：ld 返回 1
> make: *** [Makefile:290：dos2unix.exe] 错误 1
> ```
>
> 于是索性把 Makefile 中，相关的`-liconv`都删除掉
>
> ```shell
> ifeq (cygwin,$(OS))
> ifdef ENABLE_NLS
>         #LDFLAGS_EXTRA = -lintl -liconv -Wl,--enable-auto-import
>         LDFLAGS_EXTRA = -lintl -Wl,--enable-auto-import
> endif
> ```
>
> 然后编译，终于不说 `liconv`的事了
>
> ##### C、报错说 Cygwin 下没有找到 `msgfmt`命令
>
> ```shell
> $ make
> gcc dos2unix.o querycp.o common.o  -lintl -Wl,--enable-auto-import  -o dos2unix.exe
> ln -f dos2unix.exe mac2unix.exe
> msgfmt -c po/nl.po -o po/nl.mo
> make：msgfmt：命令未找到
> make: *** [Makefile:328：po/nl.mo] 错误 127
> ```
>
> 百度之，说是要安装`gettext`，于是在 cygwin 下进入`gettext-0.18.1.1`目录，光`./configure`命令，至少执行了40分钟，然后一运行`make`，就报错了
>
> ```shell
> .libs/relocatable.o: In function `DllMain':
> /cygdrive/c/Users/Administrator/Downloads/gettext-0.18.1.1/gettext-runtime/intl/./relocatable.c:324: undefined reference to `cygwin_conv_to_posix_path'
> /cygdrive/c/Users/Administrator/Downloads/gettext-0.18.1.1/gettext-runtime/intl/./relocatable.c:324:(.text+0x133): relocation truncated to fit: R_X86_64_PC32 against undefined symbol `cygwin_conv_to_posix_path'
> collect2: error: ld returned 1 exit status
> make[3]: *** [Makefile:221：libintl.la] 错误 1
> make[3]: 离开目录“/cygdrive/c/Users/Administrator/Downloads/gettext-0.18.1.1/gettext-runtime/intl”
> make[2]: *** [Makefile:1054：all-recursive] 错误 1
> make[2]: 离开目录“/cygdrive/c/Users/Administrator/Downloads/gettext-0.18.1.1/gettext-runtime”
> make[1]: *** [Makefile:957：all] 错误 2
> make[1]: 离开目录“/cygdrive/c/Users/Administrator/Downloads/gettext-0.18.1.1/gettext-runtime”
> make: *** [Makefile:277：all-recursive] 错误 1
> ```
>
> #####D、最张放弃 Cygwin 下的安装
>
> 



## [22:12]发现有好多的 linux 发行版本

>获取任意 linux 操作系统安装镜像：

	http://mirrors.ustc.edu.cn



顺手下载了 Debian9、CentOS7网络版、Deepin、linuxmint等等

### [22:13] 安装 CentOS7 网络版[CentOS-7-x86_64-NetInstall-1708.iso]()

>一、选择安装源
>
>![centos7-netinstall_1.png](./2018-01/centos7-netinstall_1.png)
>
>二、首先要配置好网络
>
>![centos7-netinstall_2.png](./2018-01/centos7-netinstall_2.png)
>
>三、配置好新安装环境的 IP
>
>![centos7-netinstall_3.png](./2018-01/centos7-netinstall_3.png)
>
>四、已经全部填写完毕。但是最下方仍然提示，有两项没有填写完毕。
>
>​     经验证，`http://mirror.centos.org/centos/7/os/x86_64/`这个网址是有效的。
>
>​     据自己猜测，应该是网络连不通外网，虽然局域网能拼通新加的 192.168.1.36.
>
>​     但是它不一定能上得了外网。于是只能就此打住。
>
>五、网上有人说与时区有关，于是把时区设置正确，然后再把 SECURITY POLICY 随便选上几项，
>
>​    然后竟然都可选了，于是选择了一个最复杂的开发服务器类型，安装包极多，极大
>
>![centos7-netinstall_44.png](./2018-01/centos7-netinstall_4.png)
>
>六、进入正常安装流程
>
>![centos7-netinstall_5.png](./2018-01/centos7-netinstall_5.png)
>
>七、至此，已经和光盘安装完全一致。可以安心睡觉去了[22:50]
>
>

## 2018-01-16

###[6:02]一大清早，弄好个 [cppunitlite](./2018-01/cppunitelite.tar)，及时上传github

## 2018-01-17

###[21:13]终于将 [cppunitlite](https://user:password@github.com/HateIron/IndependentModules.git)弄好，达到我心中的目标

> ####漂亮的 Makefile 如下：

```shell
CXX = gcc
LD  = g++

CXXFLAGS = -g
#CXXFLAGS= -g -DMyMacro

LDFLAGS  = -o
OBJ_DIR  = ./libs
ModuleDir= ./Debug

INCS     =-I./include
LIBS     = 
#LIBS    = -lwinsock32

vpath  %.c   ./source
vpath  %.cpp ./source
vpath  %.cpp ./example

EXE_NAME = ut
###################################################
SRC  = $(notdir $(wildcard ./source/*.c))
SRCC = $(notdir $(wildcard ./source/*.cpp))
ExampleSRCC = 
#ExampleSRCC = $(notdir $(wildcard ./example/*.cpp))

OBJS = $(SRC:%.c=$(ModuleDir)/%.o) $(SRCC:%.cpp=$(ModuleDir)/%.o)
#ExampleSRCCObj=
ExampleSRCCObj=$(ExampleSRCC:%.cpp=$(ModuleDir)/%.o)
#OBJS= $(patsubst %.c,$(ModuleDir)/%.o, $(SRC)) \
#	   $(patsubst %.cpp,$(ModuleDir)/%.o, $(SRCC))

${EXE_NAME} : ${OBJS} ${ExampleSRCCObj}
	ar rcso ${OBJ_DIR}/frame.a ${OBJS}	
ifeq ($(ExampleSRCC),)
else
	${LD} ${CXXFLAGS} ${INCS} ${OBJS} ${ExampleSRCCObj}  -o $@
	clear
	echo now is testing....
	./ut.exe	
endif
	rm ${ModuleDir} -rf

# compile windows dll
#${LD} ${CXXFLAGS} ${LDFLAGS} ${ModuleDir}/frame.dll ${OBJS} -W1, --output-def,${ModuleDir}/frame.def,--output-implib,${ModuleDir}/frame.a
#${LD} ${CXXFLAGS} ${LDFLAGS} frame.dll ${OBJS} -w1, --output-def, frame.def,--output-implib,frame.a
#gcc -g shared -o foo.dll foo.c print.c -w1,--output-def, print.def,--output-implib, foo.a
#${LD} ${LDFLAGS} $@ ${OBJS} ${LIBS}

depend_dir :
	mkdir -p ${ModuleDir}
	mkdir -p ${OBJ_DIR}

$(ModuleDir)/%.o : %.cpp | depend_dir
	${LD} -c ${CXXFLAGS} ${INCS} $< -o $@

$(ModuleDir)/%.o : %.c | depend_dir
	${CXX} ${CXXFLAGS} ${INCS} $< -o $@
	
.PHONY : clean
clean:
	@rm log result -rf
	@rm {EXE_NAME} -rf
	@rm ${ModuleDir} -rf
check:
	@./${EXE_NAME}
```

> #### 用户使用说明书：
>
> ```shell
> 用法：
> 1、make 生成测试框架 frame.a，不带 main 函数.
> 	这种场景下，要使用外部的 main 函数
> 2、make main=1 会同时生成带 main 函数的 frame.a 和 ut.exe
>     而且同时会运行 ./ut.exe,效果很拉风
> 3、CHECK_AND_SAVE 宏要依赖外部模块，外部模块自己实现
> 	AddFailStr(#CaseName)和AddSuccStr(#CaseName) 函数，
> 	这应该不是一件难事，而是一件很有意思的事情。
> 	如果没有外部实现也没有关系，只要不用这两个宏就可以了。
> ```

> #### 编译全部独立模块的脚本
>
> ```shell
> currDir = $(shell pwd)
> IndependentModuleDir = ${currDir}
>
> SUBDIRS = ${IndependentModuleDir}/cppUnitLite \
> 	  ${IndependentModuleDir}/shttpd/src  
>
> all:
> 	@list='$(SUBDIRS)';      \
> 	for subdir in $$list; do \
> 		echo "clean before make in $$subdir";\
> 		(cd $$subdir && make clean);         \
> 	done;                                        \
> 	for subdir in $$list; do \
> 		echo "now is Making $$subdir";       \
> 		(cd $$subdir && make)                \
> 	done;
>
> .PHONY : clean
> clean:
> 	@list='$(SUBDIRS)';      \
> 	for subdir in $$list; do \
> 		echo "cleaning $$subdir";    \
> 		(cd $$subdir && make clean); \
> 	done;
> ```



### [21:41] linux 下 `./bash_profile`的一些配置

```shell
PATH=$PATH:$HOME/.local/bin:$HOME/bin
export SVN_EDITOR=vim
export GIT_EDITOR=vim
export PATH
export PS1="[\[\e[36m\]\u][\e]]....... 漂亮的风格设置
```

> #### `svn add `命令，递归增加目录下所有文件
>
> ```shell
> svn add ./ --no-ignore --force
> ```
>
> 但是仍然报错，原因是这里的部分子目录里面也有`.svn`目录，冲突了。所以必须先将原来的 `.svn`先删除干净，然后再添加
>
> ```shell
> find ./ -name '.svn' | xargs rm -rf
> svn add ./ --no-ignore --force
> ```
>
> 



## [21:50]自己整理一条命令工具，用于将C代码的 `tab`转化成四个空格

```shell
# cd /usr/bin
# touch tab2space
# vim tab2space
sed -i -e 's/\t/    /g' `find ./ -name '*.[c|h]'`
```



### [21:53]查看 `git`每次的入库详情

```shell
1、git log --name-status   #每次修改的文件列表，显示状态
2、git log --name-only     #每次修改的文件列表
3、git log --stat          #每次修改的文件列表，及文件修改的统计
4、git whatchanged --stat  #每次修改的文件列表，及文件修改的统计
5、git show                #显示最后一次的文件改变的具体内容
```



### [21:57]Makefile 覆盖默认值

```shell
$ cat Makefile
.PHONY:all
AGE=12
all:
        @echo "age=${AGE}"
```

> #### 这个 Makefile 中，AGE默认值为 12，执行 make 输出 `age=44`，但是执行`make AGE=35`则输出 age=35
>
> ```shell
> $ make AGE=44
> age=44
> ```



### [22:35]本该研究一下 `linux`下的串口通信。无奈时间太晚，只得准备睡觉

> #### 有心人列出的学习资料，抄之；
>
> ​	http://blog.csdn.net/alais/article/details/632567



## 2018-01-19

### [4:45]_[libmodbus-0.0.1.tar.gz](./2018-01/libmodbus-0.0.1.tar.gz) 安装成功

> ##### 具体的安装过程还挺复杂：
>
> 1、解压代码包，将其中的`libmodbus.so`/`master-exemple`/`slave-exemple`先删除，但是却发现`master-exemple`/`slave-exemple`根本删除不掉。暂且不管
>
> 2、解决编译报错
>
> ```shell
> [root@localhost libmodbus-0.0.1]# make
> gcc -Wall -O3 -c commun.c -I.
> commun.c: In function ‘Mb_open_device’:
> commun.c:124:23: warning: argument to ‘sizeof’ in ‘bzero’ call is the same expression as the destination; did you mean to remove the addressof? [-Wsizeof-pointer-memaccess]
>    bzero(&Mb_tio,sizeof(&Mb_tio));
>                        ^
> gcc -Wall -O3 -c  mbs.c -I.
> mbs.c: In function ‘Mbs’:
> mbs.c:329:9: error: label at end of compound statement
>          default:
>          ^~~~~~~
> make: *** [mbs.o] Error 1
> [root@localhost libmodbus-0.0.1]# 
> ```
>
> 很快解决这是代码级错误，在 `mbs.c:329`后面加上一句 `break`;
>
> ```c
> 326                if(Mb_ptr_end_slve!=NULL)
> 327                   (*Mb_ptr_end_slve)(fonction,adresse,longueur);
> 328                         break;
> 329                 default:break;
> 330          }
> ```
>
> 再次编译，仍然报错
>
> ```shell
> [root@localhost libmodbus-0.0.1]# make
> gcc -Wall -O3 -c  mbs.c -I.
> gcc -Wall -O3 -c  mbm.c -I.
> gcc -Wall -O3 -o libmodbus.so commun.o mbs.o  mbm.o -lpthread  -shared -I.
> /usr/bin/ld: commun.o: relocation R_X86_64_32 against `.rodata.str1.1' can not be used when making a shared object; recompile with -fPIC
> commun.o: error adding symbols: Bad value
> collect2: error: ld returned 1 exit status
> make: *** [libmodbus] Error 1
> [root@localhost libmodbus-0.0.1]# 
> ```
>
> 要求增加`-fpic`编译选项，以生成位置无关代码，那是真正的共享库，但是实际操作中，发现添加`-fpic`或`-fPIC`都是可以的，具体细节已经忘记，需要再看《程序员的自我修养》
>
> ```shell
> [root@localhost libmodbus-0.0.1]# vim Makefile 
> CC      = gcc
> #CFLAGS = -Wall -O3
> CFLAGS  = -Wall -O3 -fPIC #或者 CFLAGS  = -Wall -O3 -fpic
> ```
>
> 然后继续编译
>
> ```shell
> [root@localhost libmodbus-0.0.1]# make clean
> rm -f  ~* *~ *.ASV *.bak *.o core> /dev/null
> [root@localhost libmodbus-0.0.1]# make
> gcc -Wall -O3 -fpic -c commun.c -I.
> commun.c: In function ‘Mb_open_device’:
> commun.c:124:23: warning: argument to ‘sizeof’ in ‘bzero’ call is the same expression as the destination; did you mean to remove the addressof? [-Wsizeof-pointer-memaccess]
>    bzero(&Mb_tio,sizeof(&Mb_tio));
>                        ^
> gcc -Wall -O3 -fpic -c  mbs.c -I.
> gcc -Wall -O3 -fpic -c  mbm.c -I.
> gcc -Wall -O3 -fpic -o libmodbus.so commun.o mbs.o  mbm.o -lpthread  -shared -I.
> [root@localhost libmodbus-0.0.1]# ls
> AUTHORS   commun.o  libmodbus.html  Makefile          master-exemple  mbm.o  mbs.o     README           slave-exemple
> commun.c  COPYING   libmodbus.so    master-example.c  mbm.c           mbs.c  modbus.h  slave-example.c
> [root@localhost libmodbus-0.0.1]# 
> ```
>
> 发现编译成功
>
> 3、安装程序
>
> ```shell
> [root@localhost libmodbus-0.0.1]# ls
> AUTHORS   commun.o  libmodbus.html  Makefile          master-exemple  mbm.o  mbs.o     README           slave-exemple
> commun.c  COPYING   libmodbus.so    master-example.c  mbm.c           mbs.c  modbus.h  slave-example.c
> ```
>
> 可以看到已经生成共享库 `libmodbus.so`，然后安装
>
> ```shell
> [root@localhost libmodbus-0.0.1]# make install
> chown root.root libmodbus.so
> cp libmodbus.so /usr/lib/
> cp modbus.h /usr/include
> mkdir /usr/doc/libmodbus
> mkdir: cannot create directory ‘/usr/doc/libmodbus’: No such file or directory
> make: *** [install] Error 1
> ```
>
> 说无法生成`/usr/doc/libmodbus`，于是查看 `Makefi`le并修改之，需要先建立`/usr/doc/`
>
> ```shell
> install:
>         chown root.root libmodbus.so
>         cp libmodbus.so /usr/lib/
>         cp modbus.h /usr/include
>         mkdir -p /usr/doc            #增加一句
>         mkdir -p /usr/doc/libmodbus  #修改一下，增加 -p 参数
>         cp README /usr/doc/libmodbus
>         cp AUTHORS /usr/doc/libmodbus
>         cp COPYING /usr/doc/libmodbus
> ```
>
> 再次安装，终于成功
>
> ```shell
> [root@localhost libmodbus-0.0.1]# make install
> chown root.root libmodbus.so
> cp libmodbus.so /usr/lib/
> cp modbus.h /usr/include
> mkdir -p /usr/doc
> mkdir /usr/doc/libmodbus
> cp README /usr/doc/libmodbus
> cp AUTHORS /usr/doc/libmodbus
> cp COPYING /usr/doc/libmodbus
> ```
>
> 4、弯路
>
> ​	`libmodbus`库编译安装成功之后，由于看到目录下有之前未删除成功的`master-exemple`/`slave-exemple`两个可执行程序，遂将它们当作自己编译出来的可执行文件，运行之
>
> ```shell
> [root@localhost libmodbus-0.0.1]# ./master-exemple 
> ./master-exemple: error while loading shared libraries: libmodbus.so: wrong ELF class: ELFCLASS64
> [root@localhost libmodbus-0.0.1]# ./slave-exemple 
> ./slave-exemple: error while loading shared libraries: libmodbus.so: wrong ELF class: ELFCLASS64
> [root@localhost libmodbus-0.0.1]# 
> ```
>
> 两个都报错：` wrong ELF class: ELFCLASS64`，百度有人这样说：是因为64位机器安装了32位的程序，需要安装一些32位机相关的动态链接库，人家提示安装`glibc.i686`
>
> ```shell
> yum install glibc.i686  #幸亏自己有 CentOS-Everything.iso
> ```
>
> 很快安装好，再次执行
>
> ```shell
> [root@localhost libmodbus-0.0.1]# ./master-exemple 
> ./master-exemple: error while loading shared libraries: libmodbus.so: wrong ELF class: ELFCLASS64
> ```
>
> 问题依旧。于是认真查看 Makefile 中与平台相关的代码，却没有找到，再查看C代码中相关配置，也没有。
>
> 于是意识到 `master-exemple`/`slave-exemple` 都是以前人家编译好的，我不能使用。
>
> 5、成功编译/运行测试用例
>
> 打开`master-example.c `，前两行就提示如何编译
>
> ```c
> #include <modbus.h>
> /* compiling : gcc master-example.c -o master-example -lmodbus */
> ```
>
> 于是编译之
>
> ```shell
> [root@localhost libmodbus-0.0.1]# gcc master-example.c -o master-example -lmodbus
>
> [root@localhost libmodbus-0.0.1]# ./master-example 
> ./master-example2: error while loading shared libraries: libmodbus.so: cannot open shared object file: No such file or directory
> ```
>
> 运行报错，说找不到动态链接库，更新一下动态链接库：
>
> ```
> [root@localhost libmodbus-0.0.1]# ldconfig 
> ```
>
> 再次执行，终于成功，因为虚拟机，无法操作实际串口，总之，程序跑了起来
>
> ```
> [root@localhost libmodbus-0.0.1]# ./master-example 
> Can't get terminal parameters : Input/output error
> send packet length 25
> send packet[0] = 1
> send packet[1] = 10
> send packet[2] = b0
> send packet[3] = 0
> send packet[4] = 0
> send packet[5] = 8
> send packet[6] = 10
> send packet[7] = 0
> send packet[8] = 1
> send packet[9] = 0
> send packet[10] = 2
> send packet[11] = 0
> send packet[12] = 3
> send packet[13] = 0
> send packet[14] = 4
> send packet[15] = 0
> send packet[16] = 5
> send packet[17] = 0
> send packet[18] = 5
> send packet[19] = 0
> send packet[20] = 5
> send packet[21] = 0
> send packet[22] = 5
> send packet[23] = 1
> send packet[24] = 32
> sleeping 1000 ms
> start writing 
> write ok
> starting receiving data, total length : 8 
> receiving byte :0x0 0 (0)
> receiving byte :0x0 0 (0)
> receiving byte :0x0 0 (0)
> ```
>
> 最后，`./slave-example`也是同样操作
>
> ```
> [root@localhost libmodbus-0.0.1]# gcc slave-example.c -o slave-example -lmodbus
> [root@localhost libmodbus-0.0.1]# ./slave-example 
> Can't get terminal parameters : Input/output error
> ```
>
> 





##[上月](../2017/2017-12.html)                                                        [下月](./2018-02.html)  







